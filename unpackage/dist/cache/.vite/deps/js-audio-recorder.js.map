{
  "version": 3,
  "sources": ["../../../../../node_modules/js-audio-recorder/dist/webpack:/[name]/webpack/universalModuleDefinition", "../../../../../node_modules/js-audio-recorder/dist/webpack:/[name]/webpack/bootstrap", "../../../../../node_modules/js-audio-recorder/dist/webpack:/[name]/src/transform/transform.ts", "../../../../../node_modules/js-audio-recorder/dist/webpack:/[name]/src/index.ts", "../../../../../node_modules/js-audio-recorder/dist/webpack:/[name]/src/download/download.ts", "../../../../../node_modules/js-audio-recorder/dist/webpack:/[name]/src/player/player.ts", "../../../../../node_modules/js-audio-recorder/dist/webpack:/[name]/src/exception/exception.ts", "../../../../../node_modules/js-audio-recorder/dist/webpack:/[name]/src/recorder/recorder.ts", "../../../../../node_modules/js-audio-recorder/index.js"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Recorder\"] = factory();\n\telse\n\t\troot[\"Recorder\"] = factory();\n})(this, function() {\nreturn ", " \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n", "interface dataview {\r\n    byteLength: number,\r\n    buffer: {\r\n        byteLength: number,\r\n    },\r\n    getUint8: any,\r\n}\r\n\r\n/**\r\n * 在data中的offset位置开始写入str字符串\r\n * @param {TypedArrays} data    二进制数据\r\n * @param {Number}      offset  偏移量\r\n * @param {String}      str     字符串\r\n */\r\nfunction writeString(data, offset, str): void {\r\n    for (let i = 0; i < str.length; i++) {\r\n        data.setUint8(offset + i, str.charCodeAt(i));\r\n    }\r\n}\r\n\r\n/**\r\n * 数据合并压缩\r\n * 根据输入和输出的采样率压缩数据，\r\n * 比如输入的采样率是48k的，我们需要的是（输出）的是16k的，由于48k与16k是3倍关系，\r\n * 所以输入数据中每隔3取1位\r\n *\r\n * @param {float32array} data       [-1, 1]的pcm数据\r\n * @param {number} inputSampleRate  输入采样率\r\n * @param {number} outputSampleRate 输出采样率\r\n * @returns  {float32array}         压缩处理后的二进制数据\r\n */\r\nexport function compress(data, inputSampleRate: number, outputSampleRate: number) {\r\n    // 压缩，根据采样率进行压缩\r\n    let rate = inputSampleRate / outputSampleRate,\r\n        compression = Math.max(rate, 1),\r\n        lData = data.left,\r\n        rData = data.right,\r\n        length = Math.floor(( lData.length + rData.length ) / rate),\r\n        result = new Float32Array(length),\r\n        index = 0,\r\n        j = 0;\r\n\r\n    // 循环间隔 compression 位取一位数据\r\n    while (index < length) {\r\n        // 取整是因为存在比例compression不是整数的情况\r\n        let temp = Math.floor(j);\r\n\r\n        result[index] = lData[temp];\r\n        index++;\r\n\r\n        if (rData.length) {\r\n            /*\r\n            * 双声道处理\r\n            * e.inputBuffer.getChannelData(0)得到了左声道4096个样本数据，1是右声道的数据，\r\n            * 此处需要组和成LRLRLR这种格式，才能正常播放，所以要处理下\r\n            */\r\n            result[index] = rData[temp];\r\n            index++;\r\n        }\r\n\r\n        j += compression;\r\n    }\r\n    // 返回压缩后的一维数据\r\n    return result;\r\n}\r\n\r\n/**\r\n * 转换到我们需要的对应格式的编码\r\n *\r\n * @param {float32array} bytes      pcm二进制数据\r\n * @param {number}  sampleBits      采样位数\r\n * @param {boolean} littleEdian     是否是小端字节序\r\n * @returns {dataview}              pcm二进制数据\r\n */\r\nexport function encodePCM(bytes, sampleBits: number, littleEdian: boolean = true) {\r\n    let offset = 0,\r\n        dataLength = bytes.length * (sampleBits / 8),\r\n        buffer = new ArrayBuffer(dataLength),\r\n        data = new DataView(buffer);\r\n\r\n    // 写入采样数据\r\n    if (sampleBits === 8) {\r\n        for (let i = 0; i < bytes.length; i++, offset++) {\r\n            // 范围[-1, 1]\r\n            let s = Math.max(-1, Math.min(1, bytes[i]));\r\n            // 8位采样位划分成2^8=256份，它的范围是0-255;\r\n            // 对于8位的话，负数*128，正数*127，然后整体向上平移128(+128)，即可得到[0,255]范围的数据。\r\n            let val = s < 0 ? s * 128 : s * 127;\r\n            val = +val + 128;\r\n            data.setInt8(offset, val);\r\n        }\r\n    } else {\r\n        for (let i = 0; i < bytes.length; i++, offset += 2) {\r\n            let s = Math.max(-1, Math.min(1, bytes[i]));\r\n            // 16位的划分的是2^16=65536份，范围是-32768到32767\r\n            // 因为我们收集的数据范围在[-1,1]，那么你想转换成16位的话，只需要对负数*32768,对正数*32767,即可得到范围在[-32768,32767]的数据。\r\n            data.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, littleEdian);\r\n        }\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\n/**\r\n * 编码wav，一般wav格式是在pcm文件前增加44个字节的文件头，\r\n * 所以，此处只需要在pcm数据前增加下就行了。\r\n *\r\n * @param {DataView} bytes           pcm二进制数据\r\n * @param {number}  inputSampleRate  输入采样率\r\n * @param {number}  outputSampleRate 输出采样率\r\n * @param {number}  numChannels      声道数\r\n * @param {number}  oututSampleBits  输出采样位数\r\n * @param {boolean} littleEdian      是否是小端字节序\r\n * @returns {DataView}               wav二进制数据\r\n */\r\nexport function encodeWAV(bytes: dataview, inputSampleRate: number, outputSampleRate: number, numChannels: number, oututSampleBits: number, littleEdian: boolean = true) {\r\n    let sampleRate = outputSampleRate > inputSampleRate ? inputSampleRate : outputSampleRate,   // 输出采样率较大时，仍使用输入的值，\r\n        sampleBits = oututSampleBits,\r\n        buffer = new ArrayBuffer(44 + bytes.byteLength),\r\n        data = new DataView(buffer),\r\n        channelCount = numChannels, // 声道\r\n        offset = 0;\r\n\r\n    // 资源交换文件标识符\r\n    writeString(data, offset, 'RIFF'); offset += 4;\r\n    // 下个地址开始到文件尾总字节数,即文件大小-8\r\n    data.setUint32(offset, 36 + bytes.byteLength, littleEdian); offset += 4;\r\n    // WAV文件标志\r\n    writeString(data, offset, 'WAVE'); offset += 4;\r\n    // 波形格式标志\r\n    writeString(data, offset, 'fmt '); offset += 4;\r\n    // 过滤字节,一般为 0x10 = 16\r\n    data.setUint32(offset, 16, littleEdian); offset += 4;\r\n    // 格式类别 (PCM形式采样数据)\r\n    data.setUint16(offset, 1, littleEdian); offset += 2;\r\n    // 声道数\r\n    data.setUint16(offset, channelCount, littleEdian); offset += 2;\r\n    // 采样率,每秒样本数,表示每个通道的播放速度\r\n    data.setUint32(offset, sampleRate, littleEdian); offset += 4;\r\n    // 波形数据传输率 (每秒平均字节数) 声道数 × 采样频率 × 采样位数 / 8\r\n    data.setUint32(offset, channelCount * sampleRate * (sampleBits / 8), littleEdian); offset += 4;\r\n    // 快数据调整数 采样一次占用字节数 声道数 × 采样位数 / 8\r\n    data.setUint16(offset, channelCount * (sampleBits / 8), littleEdian); offset += 2;\r\n    // 采样位数\r\n    data.setUint16(offset, sampleBits, littleEdian); offset += 2;\r\n    // 数据标识符\r\n    writeString(data, offset, 'data'); offset += 4;\r\n    // 采样数据总数,即数据总大小-44\r\n    data.setUint32(offset, bytes.byteLength, littleEdian); offset += 4;\r\n\r\n    // 给wav头增加pcm体\r\n    for (let i = 0; i < bytes.byteLength;) {\r\n        data.setUint8(offset, bytes.getUint8(i));\r\n        offset++;\r\n        i++;\r\n    }\r\n\r\n    return data;\r\n}\r\n", "import { downloadPCM, downloadWAV, download } from './download/download';\r\nimport { compress, encodePCM, encodeWAV } from './transform/transform';\r\nimport Player from './player/player';\r\nimport Recorder from './recorder/recorder';\r\n\r\ndeclare let window: any;\r\ndeclare let Math: any;\r\ndeclare let navigator: any;\r\ndeclare let Promise: any;\r\n\r\n// 构造函数参数格式\r\ninterface recorderConfig {\r\n    sampleBits?: number,        // 采样位数\r\n    sampleRate?: number,        // 采样率\r\n    numChannels?: number,       // 声道数\r\n    compiling?: boolean,        // 是否边录边播\r\n}\r\n\r\nclass Index extends Recorder {\r\n    private isrecording: boolean = false;       // 是否正在录音\r\n    private ispause: boolean = false;           // 是否是暂停\r\n    private isplaying: boolean = false;         // 是否正在播放\r\n\r\n    public onplay: () => void;                  // 音频播放回调\r\n    public onpauseplay: () => void;             // 音频暂停回调\r\n    public onresumeplay: () => void;            // 音频恢复播放回调\r\n    public onstopplay: () => void;              // 音频停止播放回调\r\n    public onplayend: () => void;               // 音频正常播放结束\r\n    /**\r\n     * @param {Object} options 包含以下三个参数：\r\n     * sampleBits，采样位数，一般8,16，默认16\r\n     * sampleRate，采样率，一般 11025、16000、22050、24000、44100、48000，默认为浏览器自带的采样率\r\n     * numChannels，声道，1或2\r\n     */\r\n    constructor(options: recorderConfig = {}) {\r\n        super(options);\r\n    }\r\n\r\n    /**\r\n     * 重新修改配置\r\n     *\r\n     * @param {recorderConfig} [options={}]\r\n     * @memberof Recorder\r\n     */\r\n    public setOption(options: recorderConfig = {}) {\r\n        this.setNewOption(options);\r\n    }\r\n\r\n    /**\r\n     * Start the recording\r\n     */\r\n    start(): Promise<{}> {\r\n        if (this.isrecording) {\r\n            // 正在录音，则不允许\r\n            return Promise.reject();\r\n        }\r\n\r\n        this.isrecording = true;\r\n\r\n        return this.startRecord();\r\n    }\r\n\r\n    /**\r\n     * Pause the recording\r\n     */\r\n    pause(): void {\r\n        if (this.isrecording && !this.ispause) {\r\n            this.ispause = true;\r\n            // 当前不暂停的时候才可以暂停\r\n            this.pauseRecord();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 继续录音\r\n     */\r\n    resume(): void {\r\n        if (this.isrecording && this.ispause) {\r\n            this.ispause = false;\r\n            this.resumeRecord();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 停止录音\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    stop(): void {\r\n        if (this.isrecording) {\r\n            this.isrecording = false;\r\n            this.ispause = false;\r\n            this.stopRecord();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 播放录音\r\n     */\r\n    play(): void {\r\n        this.stop();\r\n        // 关闭前一次音频播放\r\n        this.isplaying = true;\r\n\r\n        this.onplay && this.onplay();\r\n        Player.addPlayEnd(this.onplayend);  // 注册播放完成后的回调事件\r\n\r\n        const dataV = this.getWAV();\r\n\r\n        if (dataV.byteLength > 44) {\r\n            Player.play(dataV.buffer);  // 播放\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取已经播放了多长时间\r\n     */\r\n    getPlayTime(): number {\r\n        return Player.getPlayTime();\r\n    }\r\n\r\n    /**\r\n     * 暂停播放录音\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    pausePlay(): void {\r\n        if (this.isrecording || !this.isplaying) {\r\n            // 正在录音或没有播放，暂停无效\r\n            return;\r\n        }\r\n\r\n        this.isplaying = false;\r\n        this.onpauseplay && this.onpauseplay();\r\n        Player.pausePlay();\r\n    }\r\n\r\n    /**\r\n     * 恢复播放录音\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    resumePlay(): void {\r\n        if (this.isrecording || this.isplaying) {\r\n            // 正在录音或已经播放或没开始播放，恢复无效\r\n            return;\r\n        }\r\n\r\n        this.isplaying = true;\r\n        this.onresumeplay && this.onresumeplay();\r\n        Player.resumePlay();\r\n    }\r\n\r\n    /**\r\n     * 停止播放\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    stopPlay(): void {\r\n        if (this.isrecording) {\r\n            // 正在录音，停止录音播放无效\r\n            return;\r\n        }\r\n\r\n        this.isplaying = false;\r\n        this.onstopplay && this.onstopplay();\r\n        Player.stopPlay();\r\n    }\r\n\r\n    destroy(): Promise<{}> {\r\n        Player.destroyPlay();\r\n\r\n        return this.destroyRecord();\r\n    }\r\n\r\n    /**\r\n     * 获取当前已经录音的PCM音频数据\r\n     *\r\n     * @returns[DataView]\r\n     * @memberof Recorder\r\n     */\r\n    // getWholeData() {\r\n    //     return this.tempPCM;\r\n    // }\r\n\r\n    /**\r\n     * 获取余下的新数据，不包括 getNextData 前一次获取的数据\r\n     *\r\n     * @returns [DataView]\r\n     * @memberof Recorder\r\n     */\r\n    // getNextData() {\r\n    //     let length = this.tempPCM.length,\r\n    //         data = this.tempPCM.slice(this.offset);\r\n\r\n    //     this.offset = length;\r\n\r\n    //     return data;\r\n    // }\r\n\r\n    /**\r\n     * 获取当前录音的波形数据，\r\n     * 调取频率由外部控制。\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    getRecordAnalyseData(): any {\r\n        return this.getAnalyseData();\r\n    }\r\n\r\n    /**\r\n     * 获取录音播放时的波形数据，\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    getPlayAnalyseData(): any {\r\n        // 现在录音和播放不允许同时进行，所有复用的录音的analyser节点。\r\n        return Player.getAnalyseData();\r\n    }\r\n\r\n    getPCM(): any {\r\n        // 先停止\r\n        this.stop();\r\n        // 获取pcm数据\r\n        let data: any = this.getData();\r\n        // 根据输入输出比例 压缩或扩展\r\n        data = compress(data, this.inputSampleRate, this.outputSampleRate);\r\n        // 按采样位数重新编码\r\n        return encodePCM(data, this.oututSampleBits, this.littleEdian);\r\n    }\r\n\r\n    /**\r\n     * 获取PCM格式的blob数据\r\n     *\r\n     * @returns { blob }  PCM格式的blob数据\r\n     * @memberof Recorder\r\n     */\r\n    getPCMBlob(): any {\r\n        return new Blob([ this.getPCM() ]);\r\n    }\r\n\r\n    /**\r\n     * 下载录音pcm数据\r\n     *\r\n     * @param {string} [name='recorder']    重命名的名字\r\n     * @memberof Recorder\r\n     */\r\n    downloadPCM(name: string = 'recorder'): void {\r\n        let pcmBlob = this.getPCMBlob();\r\n\r\n        downloadPCM(pcmBlob, name);\r\n    }\r\n\r\n    /**\r\n     * 获取WAV编码的二进制数据(dataview)\r\n     *\r\n     * @returns {dataview}  WAV编码的二进制数据\r\n     * @memberof Recorder\r\n     */\r\n    getWAV(): any {\r\n        let pcmTemp = this.getPCM();\r\n\r\n        // PCM增加44字节的头就是WAV格式了\r\n        return encodeWAV(pcmTemp, this.inputSampleRate,\r\n            this.outputSampleRate, this.config.numChannels, this.oututSampleBits, this.littleEdian);;\r\n    }\r\n\r\n    /**\r\n     * 获取WAV音频的blob数据\r\n     *\r\n     * @returns { blob }    wav格式blob数据\r\n     * @memberof Recorder\r\n     */\r\n    getWAVBlob(): any {\r\n        return new Blob([ this.getWAV() ], { type: 'audio/wav' });\r\n    }\r\n\r\n    /**\r\n     * 下载录音的wav数据\r\n     *\r\n     * @param {string} [name='recorder']    重命名的名字\r\n     * @memberof Recorder\r\n     */\r\n    downloadWAV(name: string = 'recorder'): void {\r\n        let wavBlob = this.getWAVBlob();\r\n\r\n        downloadWAV(wavBlob, name);\r\n    }\r\n\r\n    /**\r\n     * 通用的下载接口\r\n     */\r\n    download(blob, name: string, type: string): void {\r\n        download(blob, name, type);\r\n    }\r\n\r\n    /**\r\n     * 获取左和右声道的数据\r\n     *\r\n     * @returns [DataView]\r\n     */\r\n    getChannelData(): any {\r\n        const all = this.getPCM();\r\n        const length = all.byteLength;\r\n        const littleEdian = this.littleEdian\r\n        const res = { left: null, right: null }\r\n\r\n        if (this.config.numChannels === 2) {\r\n            // 双通道,劈开\r\n            const lD = new DataView(new ArrayBuffer(length / 2))\r\n            const rD = new DataView(new ArrayBuffer(length / 2))\r\n            // 双声道，需要拆分下数据\r\n\r\n            if (this.config.sampleBits === 16) {\r\n                for (var i = 0; i < length / 2; i += 2) {\r\n                    lD.setInt16(i, all.getInt16(i * 2, littleEdian), littleEdian)\r\n                    rD.setInt16(i, all.getInt16(i * 2 + 2, littleEdian), littleEdian)\r\n                }\r\n            } else {\r\n                for (var i = 0; i < length / 2; i += 2) {\r\n                    lD.setInt8(i, all.getInt8(i * 2))\r\n                    rD.setInt8(i, all.getInt8(i * 2 + 1))\r\n                }\r\n            }\r\n\r\n            res.left = lD\r\n            res.right = rD\r\n        } else {\r\n            // 单通道\r\n            res.left = all\r\n        }\r\n\r\n        return res\r\n    }\r\n}\r\n\r\nexport default Index;\r\n", "/**\r\n * 下载录音文件\r\n * @private\r\n * @param {*} blob      blob数据\r\n * @param {string} name 下载的文件名\r\n * @param {string} type 下载的文件后缀\r\n */\r\nfunction _download(blob, name: string, type: string): void {\r\n    let oA = document.createElement('a');\r\n\r\n    oA.href = window.URL.createObjectURL(blob);\r\n    oA.download = `${ name }.${ type }`;\r\n    oA.click();\r\n}\r\n\r\n/**\r\n * 下载录音的wav数据\r\n *\r\n * @param {blob}   需要下载的blob数据类型\r\n * @param {string} [name='recorder']    重命名的名字\r\n */\r\nexport function downloadWAV(wavblob, name: string = 'recorder'): void {\r\n    _download(wavblob, name, 'wav');\r\n}\r\n\r\n/**\r\n * 下载录音pcm数据\r\n *\r\n * @param {blob}   需要下载的blob数据类型\r\n * @param {string} [name='recorder']    重命名的名字\r\n * @memberof Recorder\r\n */\r\nexport function downloadPCM(pcmBlob, name: string = 'recorder'): void {\r\n    _download(pcmBlob, name, 'pcm');\r\n}\r\n\r\n// 通用下载接口\r\nexport function download(blob, name: string, type: string) {\r\n    return _download(blob, name, type)\r\n}\r\n", "import { throwError } from '../exception/exception'\r\n\r\ndeclare let window: any;\r\n\r\nlet source: any = null;\r\nlet playTime: number = 0;       // 相对时间，记录暂停位置\r\nlet playStamp: number = 0;      // 开始或暂停后开始的时间戳(绝对)\r\nlet context: any = null;\r\nlet analyser: any = null;\r\n\r\nlet audioData: any = null;\r\n// let hasInit: boolean = false;           // 是否已经初始化了\r\nlet isPaused: boolean = false;\r\nlet totalTime: number = 0;\r\nlet endplayFn: any = function() {};\r\n\r\n/**\r\n * 初始化\r\n */\r\nfunction init(): void {\r\n    context = new (window.AudioContext || window.webkitAudioContext)();\r\n    analyser = context.createAnalyser();\r\n    analyser.fftSize = 2048;                   // 表示存储频域的大小\r\n}\r\n\r\n/**\r\n * play\r\n * @returns {Promise<{}>}\r\n */\r\nfunction playAudio(): Promise<{}> {\r\n    isPaused = false;\r\n\r\n    return context.decodeAudioData(audioData.slice(0), buffer => {\r\n        source = context.createBufferSource();\r\n\r\n        // 播放结束的事件绑定\r\n        source.onended = () => {\r\n            if (!isPaused) {  // 暂停的时候也会触发该事件\r\n                // 计算音频总时长\r\n                totalTime = context.currentTime - playStamp + playTime;\r\n                endplayFn();\r\n            }\r\n\r\n        }\r\n\r\n        // 设置数据\r\n        source.buffer = buffer;\r\n        // connect到分析器，还是用录音的，因为播放时不能录音的\r\n        source.connect(analyser);\r\n        analyser.connect(context.destination);\r\n        source.start(0, playTime);\r\n\r\n        // 记录当前的时间戳，以备暂停时使用\r\n        playStamp = context.currentTime;\r\n    }, function(e) {\r\n        throwError(e);\r\n    });\r\n}\r\n\r\n// 销毁source, 由于 decodeAudioData 产生的source每次停止后就不能使用，所以暂停也意味着销毁，下次需重新启动。\r\nfunction destroySource() {\r\n    if (source) {\r\n        source.stop();\r\n        source = null;\r\n    }\r\n}\r\n\r\nexport default class Player {\r\n    /**\r\n     * play record\r\n     * @static\r\n     * @param {ArrayBuffer} arraybuffer\r\n     * @memberof Player\r\n     */\r\n    static play(arraybuffer): Promise<{}> {\r\n        if (!context) {\r\n            // 第一次播放要初始化\r\n            init();\r\n        }\r\n        this.stopPlay();\r\n        // 缓存播放数据\r\n        audioData = arraybuffer;\r\n        totalTime = 0;\r\n\r\n        return playAudio();\r\n    }\r\n\r\n    /**\r\n     * 暂停播放录音\r\n     * @memberof Player\r\n     */\r\n    static pausePlay(): void {\r\n        destroySource();\r\n        // 多次暂停需要累加\r\n        playTime += context.currentTime - playStamp;\r\n        isPaused = true;\r\n    }\r\n\r\n    /**\r\n     * 恢复播放录音\r\n     * @memberof Player\r\n     */\r\n    static resumePlay(): Promise<{}> {\r\n        return playAudio();\r\n    }\r\n\r\n    /**\r\n     * 停止播放\r\n     * @memberof Player\r\n     */\r\n    static stopPlay() {\r\n        playTime = 0;\r\n        audioData = null;\r\n\r\n        destroySource();\r\n    }\r\n\r\n    static destroyPlay() {\r\n        this.stopPlay();\r\n    }\r\n\r\n    static getAnalyseData() {\r\n        let dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n        // 将数据拷贝到dataArray中。\r\n        analyser.getByteTimeDomainData(dataArray);\r\n\r\n        return dataArray;\r\n    }\r\n\r\n    /**\r\n     * 增加录音播放完成的事件绑定\r\n     *\r\n     * @static\r\n     * @param {*} [fn=function() {}]\r\n     * @memberof Player\r\n     */\r\n    static addPlayEnd(fn: any = function() {}) {\r\n        endplayFn = fn;\r\n    }\r\n\r\n    // 获取已经播放的时长\r\n    static getPlayTime(): number {\r\n        let pTime = isPaused ? playTime : context.currentTime - playStamp + playTime;\r\n\r\n        return totalTime || pTime;\r\n    }\r\n}\r\n", "/**\r\n * 异常处理\r\n * @static\r\n * @param {*} message   错误消息\r\n */\r\nexport function throwError(message: string) {\r\n    throw new Error(message);\r\n}\r\n", "import { compress, encodePCM, encodeWAV } from '../transform/transform';\r\n\r\ndeclare let window: any;\r\ndeclare let Math: any;\r\ndeclare let navigator: any;\r\ndeclare let Promise: any;\r\n\r\n// 构造函数参数格式\r\ninterface recorderConfig {\r\n    sampleBits?: number,        // 采样位数\r\n    sampleRate?: number,        // 采样率\r\n    numChannels?: number,       // 声道数\r\n    compiling?: boolean,        // 是否边录边播\r\n}\r\n\r\nexport default class Recorder {\r\n    private context: any;\r\n    protected config: recorderConfig;               // 配置\r\n    private analyser: any;\r\n    private size: number = 0;                       // 录音文件总长度\r\n    private lBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(左声道)\r\n    private rBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(右声道)\r\n    private PCM: any;                               // 最终的PCM数据缓存，避免多次encode\r\n    private tempPCM: Array<DataView> = [];          // 边录边转时临时存放pcm的\r\n    private audioInput: any;\r\n    protected inputSampleRate: number;              // 输入采样率\r\n    protected inputSampleBits: number = 16;         // 输入采样位数\r\n    protected outputSampleRate: number;             // 输出采样率\r\n    protected oututSampleBits: number;              // 输出采样位数\r\n    private source: any;                            // 音频输入\r\n    private recorder: any;\r\n    private stream: any;                            // 流\r\n    protected littleEdian: boolean;                 // 是否是小端字节序\r\n    protected fileSize: number = 0;                 // 录音大小，byte为单位\r\n    protected duration: number = 0;                 // 录音时长\r\n    private needRecord: boolean = true;             // 由于safari问题，导致使用该方案代替disconnect/connect方案\r\n    // 正在录音时间，参数是已经录了多少时间了\r\n    public onprocess: (duration: number) => void;\r\n    // onprocess 替代函数，保持原来的 onprocess 向下兼容\r\n    public onprogress: (payload: {\r\n        duration: number,\r\n        fileSize: number,\r\n        vol: number,\r\n        // data: Array<DataView>,      // 当前存储的所有录音数据\r\n    }) => void;\r\n    public onplay: () => void;                  // 音频播放回调\r\n    public onpauseplay: () => void;             // 音频暂停回调\r\n    public onresumeplay: () => void;            // 音频恢复播放回调\r\n    public onstopplay: () => void;              // 音频停止播放回调\r\n    public onplayend: () => void;               // 音频正常播放结束\r\n\r\n    /**\r\n     * @param {Object} options 包含以下三个参数：\r\n     * sampleBits，采样位数，一般8,16，默认16\r\n     * sampleRate，采样率，一般 11025、16000、22050、24000、44100、48000，默认为浏览器自带的采样率\r\n     * numChannels，声道，1或2\r\n     */\r\n    constructor(options: recorderConfig = {}) {\r\n        // 临时audioContext，为了获取输入采样率的\r\n        let context = new (window.AudioContext || window.webkitAudioContext)();\r\n\r\n        this.inputSampleRate = context.sampleRate;     // 获取当前输入的采样率\r\n\r\n        // 设置输出配置\r\n        this.setNewOption(options);\r\n\r\n        // 判断端字节序\r\n        this.littleEdian = (function() {\r\n            let buffer = new ArrayBuffer(2);\r\n            new DataView(buffer).setInt16(0, 256, true);\r\n            return new Int16Array(buffer)[0] === 256;\r\n        })();\r\n        // 兼容 getUserMedia\r\n        Recorder.initUserMedia();\r\n    }\r\n\r\n    protected setNewOption(options: recorderConfig = {}) {\r\n        this.config = {\r\n            // 采样数位 8, 16\r\n            sampleBits: ~[8, 16].indexOf(options.sampleBits) ? options.sampleBits : 16,\r\n            // 采样率\r\n            sampleRate: ~[8000, 11025, 16000, 22050, 24000, 44100, 48000].indexOf(options.sampleRate) ? options.sampleRate : this.inputSampleRate,\r\n            // 声道数，1或2\r\n            numChannels: ~[1, 2].indexOf(options.numChannels) ? options.numChannels : 1,\r\n            // 是否需要边录边转，默认关闭，后期使用web worker\r\n            // compiling: !!options.compiling || false,   // 先移除\r\n        };\r\n        // 设置采样的参数\r\n        this.outputSampleRate = this.config.sampleRate;     // 输出采样率\r\n        this.oututSampleBits = this.config.sampleBits;      // 输出采样数位 8, 16\r\n    }\r\n\r\n    /**\r\n     * 开始录音\r\n     *\r\n     * @returns {Promise<{}>}\r\n     * @memberof Recorder\r\n     */\r\n    startRecord(): Promise<{}> {\r\n        if (this.context) {\r\n            // 关闭先前的录音实例，因为前次的实例会缓存少量前次的录音数据\r\n            this.destroyRecord();\r\n        }\r\n        // 初始化\r\n        this.initRecorder();\r\n\r\n        return navigator.mediaDevices.getUserMedia({\r\n            audio: true\r\n        }).then(stream => {\r\n            // audioInput表示音频源节点\r\n            // stream是通过navigator.getUserMedia获取的外部（如麦克风）stream音频输出，对于这就是输入\r\n            this.audioInput = this.context.createMediaStreamSource(stream);\r\n            this.stream = stream;\r\n        }/* 报错丢给外部使用者catch，后期可在此处增加建议性提示\r\n            , error => {\r\n            // 抛出异常\r\n            Recorder.throwError(error.name + \" : \" + error.message);\r\n        } */).then(() => {\r\n            // audioInput 为声音源，连接到处理节点 recorder\r\n            this.audioInput.connect(this.analyser);\r\n            this.analyser.connect(this.recorder);\r\n            // this.audioInput.connect(this.recorder);\r\n            // 处理节点 recorder 连接到扬声器\r\n            this.recorder.connect(this.context.destination);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 暂停录音\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    pauseRecord(): void {\r\n        this.needRecord = false;\r\n    }\r\n\r\n    /**\r\n     * 继续录音\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    resumeRecord(): void {\r\n        this.needRecord = true;\r\n    }\r\n\r\n    /**\r\n     * 停止录音\r\n     *\r\n     */\r\n    stopRecord(): void {\r\n        this.audioInput && this.audioInput.disconnect();\r\n        this.source && this.source.stop();\r\n        this.recorder.disconnect();\r\n        this.analyser.disconnect();\r\n        this.needRecord = true;\r\n    }\r\n\r\n    /**\r\n     * 销毁录音对象\r\n     *\r\n     */\r\n    destroyRecord(): Promise<{}> {\r\n        this.clearRecordStatus();\r\n        // 结束流\r\n        this.stopStream();\r\n\r\n        return this.closeAudioContext();\r\n    }\r\n\r\n    getAnalyseData() {\r\n        let dataArray = new Uint8Array(this.analyser.frequencyBinCount);\r\n        // 将数据拷贝到dataArray中。\r\n        this.analyser.getByteTimeDomainData(dataArray);\r\n\r\n        return dataArray;\r\n    }\r\n\r\n    // 获取录音数据\r\n    getData() {\r\n        let data: any = this.flat();\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * 清除状态\r\n     *\r\n     */\r\n    private clearRecordStatus() {\r\n        this.lBuffer.length = 0;\r\n        this.rBuffer.length = 0;\r\n        this.size = 0;\r\n        this.fileSize = 0;\r\n        this.PCM = null;\r\n        this.audioInput = null;\r\n        this.duration = 0;\r\n    }\r\n\r\n    /**\r\n     * 将二维数组转一维\r\n     *\r\n     * @private\r\n     * @returns  {float32array}     音频pcm二进制数据\r\n     * @memberof Recorder\r\n     */\r\n    private flat() {\r\n        let lData = null,\r\n            rData = new Float32Array(0);    // 右声道默认为0\r\n\r\n        // 创建存放数据的容器\r\n        if (1 === this.config.numChannels) {\r\n            lData = new Float32Array(this.size);\r\n        } else {\r\n            lData = new Float32Array(this.size / 2);\r\n            rData = new Float32Array(this.size / 2);\r\n        }\r\n        // 合并\r\n        let offset = 0; // 偏移量计算\r\n\r\n        // 将二维数据，转成一维数据\r\n        // 左声道\r\n        for (let i = 0; i < this.lBuffer.length; i++) {\r\n            lData.set(this.lBuffer[i], offset);\r\n            offset += this.lBuffer[i].length;\r\n        }\r\n\r\n        offset = 0;\r\n        // 右声道\r\n        for (let i = 0; i < this.rBuffer.length; i++) {\r\n            rData.set(this.rBuffer[i], offset);\r\n            offset += this.rBuffer[i].length;\r\n        }\r\n\r\n        return {\r\n            left: lData,\r\n            right: rData\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 初始化录音实例\r\n     */\r\n    private initRecorder(): void {\r\n        // 清空数据\r\n        this.clearRecordStatus();\r\n\r\n        this.context = new (window.AudioContext || window.webkitAudioContext)();\r\n\r\n        this.analyser = this.context.createAnalyser();  // 录音分析节点\r\n        this.analyser.fftSize = 2048;                   // 表示存储频域的大小\r\n\r\n        // 第一个参数表示收集采样的大小，采集完这么多后会触发 onaudioprocess 接口一次，该值一般为1024,2048,4096等，一般就设置为4096\r\n        // 第二，三个参数分别是输入的声道数和输出的声道数，保持一致即可。\r\n        let createScript = this.context.createScriptProcessor || this.context.createJavaScriptNode;\r\n        this.recorder = createScript.apply(this.context, [4096, this.config.numChannels, this.config.numChannels]);\r\n\r\n        // 音频采集\r\n        this.recorder.onaudioprocess = e => {\r\n            if (!this.needRecord) {\r\n                return;\r\n            }\r\n            // 左声道数据\r\n            // getChannelData返回Float32Array类型的pcm数据\r\n            let lData = e.inputBuffer.getChannelData(0),\r\n                rData = null,\r\n                vol = 0;        // 音量百分比\r\n\r\n            this.lBuffer.push(new Float32Array(lData));\r\n\r\n            this.size += lData.length;\r\n\r\n            // 判断是否有右声道数据\r\n            if (2 === this.config.numChannels) {\r\n                rData = e.inputBuffer.getChannelData(1);\r\n                this.rBuffer.push(new Float32Array(rData));\r\n\r\n                this.size += rData.length;\r\n            }\r\n\r\n            // 边录边转处理 暂时不支持\r\n            // if (this.config.compiling) {\r\n            //     let pcm = this.transformIntoPCM(lData, rData);\r\n\r\n            //     this.tempPCM.push(pcm);\r\n            //     // 计算录音大小\r\n            //     this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n            // } else {\r\n                // 计算录音大小\r\n                this.fileSize = Math.floor(this.size / Math.max( this.inputSampleRate / this.outputSampleRate, 1))\r\n                    * (this.oututSampleBits / 8)\r\n            // }\r\n            // 为何此处计算大小需要分开计算。原因是先录后转时，是将所有数据一起处理，边录边转是单个 4096 处理，\r\n            // 有小数位的偏差。\r\n\r\n            // 计算音量百分比\r\n            vol = Math.max.apply(Math, lData) * 100;\r\n            // 统计录音时长\r\n            this.duration += 4096 / this.inputSampleRate;\r\n            // 录音时长回调\r\n            this.onprocess && this.onprocess(this.duration);\r\n            // 录音时长及响度回调\r\n            this.onprogress && this.onprogress({\r\n                duration: this.duration,\r\n                fileSize: this.fileSize,\r\n                vol,\r\n                // data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 终止流（这可以让浏览器上正在录音的标志消失掉）\r\n     * @private\r\n     * @memberof Recorder\r\n     */\r\n    private stopStream() {\r\n        if (this.stream && this.stream.getTracks) {\r\n            this.stream.getTracks().forEach(track => track.stop());\r\n            this.stream = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * close兼容方案\r\n     * 如firefox 30 等低版本浏览器没有 close方法\r\n     */\r\n    private closeAudioContext() {\r\n        if (this.context && this.context.close && this.context.state !== 'closed') {\r\n            return this.context.close();\r\n        } else {\r\n            return new Promise((resolve) => {\r\n                resolve();\r\n            });\r\n        }\r\n    }\r\n\r\n    // getUserMedia 版本兼容\r\n    static initUserMedia() {\r\n        if (navigator.mediaDevices === undefined) {\r\n            navigator.mediaDevices = {};\r\n        }\r\n\r\n        if (navigator.mediaDevices.getUserMedia === undefined) {\r\n            navigator.mediaDevices.getUserMedia = function(constraints) {\r\n                let getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\r\n\r\n                if (!getUserMedia) {\r\n                    return Promise.reject(new Error('浏览器不支持 getUserMedia !'));\r\n                }\r\n\r\n                return new Promise(function(resolve, reject) {\r\n                    getUserMedia.call(navigator, constraints, resolve, reject);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 将获取到到左右声道的Float32Array数据编码转化\r\n     *\r\n     * @param {Float32Array} lData  左声道数据\r\n     * @param {Float32Array} rData  有声道数据\r\n     * @returns DataView\r\n     */\r\n    private transformIntoPCM(lData, rData) {\r\n        let lBuffer = new Float32Array(lData),\r\n            rBuffer = new Float32Array(rData);\r\n\r\n        let data = compress({\r\n            left: lBuffer,\r\n            right: rBuffer,\r\n        }, this.inputSampleRate, this.outputSampleRate);\r\n\r\n        return encodePCM(data, this.oututSampleBits, this.littleEdian);\r\n    }\r\n\r\n    static getPermission(): Promise<{}> {\r\n        this.initUserMedia();\r\n\r\n        return navigator.mediaDevices.getUserMedia({audio: true}).then((stream) => {\r\n            stream && stream.getTracks().forEach(track => track.stop());\r\n        });\r\n    }\r\n}\r\n", "module.exports = require(\"./dist/recorder.js\");\r\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "define", "amd", "this", "installedModules", "__webpack_require__", "moduleId", "i", "l", "modules", "call", "m", "c", "d", "name", "getter", "o", "Object", "defineProperty", "enumerable", "get", "r", "Symbol", "toStringTag", "value", "t", "mode", "__esModule", "ns", "create", "key", "bind", "n", "object", "property", "prototype", "hasOwnProperty", "p", "s", "writeString", "data", "offset", "str", "length", "setUint8", "charCodeAt", "compress", "inputSampleRate", "outputSampleRate", "rate", "compression", "Math", "max", "lData", "left", "rData", "right", "floor", "result", "Float32Array", "index", "j", "temp", "encodePCM", "bytes", "sampleBits", "littleEdian", "dataLength", "buffer", "ArrayBuffer", "DataView", "val", "min", "setInt8", "setInt16", "encodeWAV", "numChannels", "oututSampleBits", "sampleRate", "byteLength", "channelCount", "setUint32", "setUint16", "getUint8", "download_1", "transform_1", "player_1", "Index", "_super", "options", "_this", "isrecording", "ispause", "isplaying", "__extends", "setOption", "setNewOption", "start", "Promise", "reject", "startRecord", "pause", "pauseRecord", "resume", "resumeRecord", "stop", "stopRecord", "play", "onplay", "default", "addPlayEnd", "onplayend", "dataV", "getWAV", "getPlayTime", "pausePlay", "onpauseplay", "resumePlay", "onresumeplay", "stopPlay", "onstopplay", "destroy", "destroyPlay", "destroyRecord", "getRecordAnalyseData", "getAnalyseData", "getPlayAnalyseData", "getPCM", "getData", "getPCMBlob", "Blob", "downloadPCM", "pcmBlob", "pcmTemp", "config", "getWAVBlob", "type", "downloadWAV", "wavBlob", "download", "blob", "getChannelData", "all", "res", "lD", "rD", "getInt16", "getInt8", "_download", "oA", "document", "createElement", "href", "window", "URL", "createObjectURL", "click", "wavblob", "exception_1", "source", "playTime", "playStamp", "context", "analyser", "audioData", "isPaused", "totalTime", "endplayFn", "playAudio", "decodeAudioData", "slice", "createBufferSource", "onended", "currentTime", "connect", "destination", "e", "throwError", "destroySource", "Player", "arraybuffer", "AudioContext", "webkitAudioContext", "createAnalyser", "fftSize", "dataArray", "Uint8Array", "frequencyBinCount", "getByteTimeDomainData", "fn", "pTime", "message", "Error", "Recorder", "size", "lBuffer", "rBuffer", "tempPCM", "inputSampleBits", "fileSize", "duration", "needRecord", "Int16Array", "initUserMedia", "indexOf", "initRecorder", "navigator", "mediaDevices", "getUserMedia", "audio", "then", "stream", "audioInput", "createMediaStreamSource", "recorder", "disconnect", "clearRecordStatus", "stopStream", "closeAudioContext", "flat", "PCM", "set", "createScript", "createScriptProcessor", "createJavaScriptNode", "apply", "onaudioprocess", "vol", "inputBuffer", "push", "onprocess", "onprogress", "getTracks", "forEach", "track", "close", "state", "resolve", "constraints", "webkitGetUserMedia", "mozGetUserMedia", "transformIntoPCM", "getPermission"]
}
